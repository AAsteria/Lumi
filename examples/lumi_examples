Feb 2, Lumi Examples:


library existed language
closure, lisp, incanter: https://github.com/incanter/incanter


We want: 

strong type system;

libraries for numerical and symbolic computation;
fast, implementation of certain features should be consistent;

concise & easy-to-learn & flexible syntax;

support lazy evaluation;

macro and code generation;


==================================================================


Examples:


1. Symbolic Computation

# Default: MODE = "normal"

3/9; # print 0.33333333333


# Smart simplification mode:

MODE = "simple";
3/9; # print 1/3



2. Matrix and List

# Initialization

A = [[3, 4, 5],
     [2, 6, 1],
     [8, 9, 0]];

prtln "Row 1:" + A[1];
prtln A[2][2];
prtln A[2~3][2~3];


B = [](3, 3); # 3*3 matrix with all entries 0
C = [1](3, 3); # 3*3 matrix with all entries 1
l = [4..9]; # list of numbers from 4 to 9

addTo l B; # action function, no returns
addTo l A[2~3][1~3];
? addTo; # help function, show usage

D = A * C; # dot product

# Eigenvalues

eig D;
eigValue D;
eigVector D;

# Determinant, k-Norm, SVD

det A;
norm 2 A;
u, w, v_t = svd A;



3. Function and Plot

# Differentiation

f = sin(x)^2+cos(x)^2;
df = diff f x
d2f = diff df x

# Plot function

plot f (0, 2*PI, 0.5*PI); # (start, stop, step)
legend f TITLE "My First Lumi Graph";
legend f X "x values from 0 to 2PI";
legend f Y "function values";
save f PNG "plot of f";
prtln f;



4. Data Structure and Functions

# Structure definition

struct Tree = 
    node :: Int;
    left :: Tree;
    right :: Tree;

# In-order traversal function

traverse root = 
    | root == None -> None;
    | OTHER ->
        traverse root.left;
        prtln root.node;
        traverse root.right;

# Example usage

myTree = Tree (1, Tree(2, None, None), Tree(3, None, None)); 
traverse myTree; # print 2, 1, 3



5. Recursion and Loop

factorial n = 
    res :: Int;
    res = | n == 0 -> 1;
   	  | OTHER -> n * factorial(n-1); 

# For loop

s = 0;
for [1..10] do:
    ++ s;

prtln s;











